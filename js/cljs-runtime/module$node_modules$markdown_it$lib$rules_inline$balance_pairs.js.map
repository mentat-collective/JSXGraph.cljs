{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$balance_pairs.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$balance_pairs\"] = function(global,require,module,exports) {\n// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];\n\n    openerIdx = closerIdx - closer.jump - 1;\n\n    // avoid crash if `closer.jump` is pointing outside of the array, see #742\n    if (openerIdx < -1) openerIdx = -1;\n\n    newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            delimiters[openerIdx - 1].jump + 1 :\n            0;\n\n          closer.jump  = closerIdx - openerIdx + lastJump;\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.jump  = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","processDelimiters","state","delimiters","newMinOpenerIdx","openersBottom","max","length","closerIdx","closer","close","hasOwnProperty","marker","minOpenerIdx","open","openerIdx","jump","opener","end","isOddMatch","lastJump","module.exports","curr","tokens_meta"]
}
